Initially I was very confused about where to start with the gdb debugging. I attemped to create the trace solely based on disassemble assembly dump at first, however I quickly realized certain parameters can cut down on which assembly lines are used. I first created the 2 columns of the trace by setting logging on, and writing the output data to a text file. To get the output nearest to the trace, I displayed the $rip pointer with  display/i $rip each time rather than dumping the whole chunk of assembly with set disassemble-next-line on. I initially made the mistake of outputting assembly with a breakpoint in arith_driver, however that ran it through loops that never reached Ftimes. Instead, putting the breakpoint in Ftimes got me the output I desired.

I thought about using a code to put the output in the structure necessary, however considering the amount of lines I needed to do, I resorted to features in Sublime Text instead, where I was able to add spaces and omit things in coloumns of the text. For the third column, I initially manually printed out the registers that were altered, however decided that printing the all the registers with info register was simpler and easier to read. I defined a macro that stepped in and printed info register each time, so the process was automated. The values in the third column I inserted manually into the trace. 

To answer the questions in answers.txt, I used the 'frame' function to print out the C code as well as the assembly below it to find out the issue. Then, used another terminal to look at the source code itself to figure out what was going on. 